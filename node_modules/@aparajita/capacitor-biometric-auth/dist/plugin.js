var capacitorBiometricAuth = (function (exports, core, app) {
    'use strict';

    exports.BiometryType = void 0;
    (function (BiometryType) {
        /**
         * No biometry is available
         */
        BiometryType[BiometryType["none"] = 0] = "none";
        /**
         * iOS Touch ID is available
         */
        BiometryType[BiometryType["touchId"] = 1] = "touchId";
        /**
         * iOS Face ID is available
         */
        BiometryType[BiometryType["faceId"] = 2] = "faceId";
        /**
         * Android fingerprint authentication is available
         */
        BiometryType[BiometryType["fingerprintAuthentication"] = 3] = "fingerprintAuthentication";
        /**
         * Android face authentication is available
         */
        BiometryType[BiometryType["faceAuthentication"] = 4] = "faceAuthentication";
        /**
         * Android iris authentication is available
         */
        BiometryType[BiometryType["irisAuthentication"] = 5] = "irisAuthentication";
    })(exports.BiometryType || (exports.BiometryType = {}));
    /**
     * If the `authenticate()` method throws an exception, the error object
     * contains a .code property which will contain one of these strings,
     * indicating what the error was.
     *
     * See https://developer.apple.com/documentation/localauthentication/laerror
     * for a description of each error code.
     */
    exports.BiometryErrorType = void 0;
    (function (BiometryErrorType) {
        BiometryErrorType["none"] = "";
        BiometryErrorType["appCancel"] = "appCancel";
        BiometryErrorType["authenticationFailed"] = "authenticationFailed";
        BiometryErrorType["invalidContext"] = "invalidContext";
        BiometryErrorType["notInteractive"] = "notInteractive";
        BiometryErrorType["passcodeNotSet"] = "passcodeNotSet";
        BiometryErrorType["systemCancel"] = "systemCancel";
        BiometryErrorType["userCancel"] = "userCancel";
        BiometryErrorType["userFallback"] = "userFallback";
        BiometryErrorType["biometryLockout"] = "biometryLockout";
        BiometryErrorType["biometryNotAvailable"] = "biometryNotAvailable";
        BiometryErrorType["biometryNotEnrolled"] = "biometryNotEnrolled";
        BiometryErrorType["noDeviceCredential"] = "noDeviceCredential";
    })(exports.BiometryErrorType || (exports.BiometryErrorType = {}));
    class BiometryError {
        constructor(message, code) {
            this.message = message;
            this.code = code;
        }
    }

    const kBiometryTypeNameMap = {
        [exports.BiometryType.none]: '',
        [exports.BiometryType.touchId]: 'Touch ID',
        [exports.BiometryType.faceId]: 'Face ID',
        [exports.BiometryType.fingerprintAuthentication]: 'Fingerprint Authentication',
        [exports.BiometryType.faceAuthentication]: 'Face Authentication',
        [exports.BiometryType.irisAuthentication]: 'Iris Authentication',
    };
    /**
     * Return a human-readable name for a BiometryType.
     */
    // eslint-disable-next-line import/prefer-default-export
    function getBiometryName(type) {
        return kBiometryTypeNameMap[type] || '';
    }

    const proxy = core.registerPlugin('BiometricAuthNative', {
        web: async () => Promise.resolve().then(function () { return web; }).then((module) => new module.BiometricAuthWeb()),
        ios: async () => Promise.resolve().then(function () { return native; }).then((module) => new module.BiometricAuthNative(proxy)),
        android: async () => Promise.resolve().then(function () { return native; }).then((module) => new module.BiometricAuthNative(proxy)),
    });

    // eslint-disable-next-line import/prefer-default-export
    class BiometricAuthBase extends core.WebPlugin {
        addResumeListener(listener) {
            return app.App.addListener('appStateChange', ({ isActive }) => {
                if (isActive) {
                    this.checkBiometry()
                        .then((info) => {
                        listener(info);
                    })
                        .catch(console.error);
                }
            });
        }
    }

    // eslint-disable-next-line import/prefer-default-export
    class BiometricAuthWeb extends BiometricAuthBase {
        constructor() {
            super(...arguments);
            this.biometryType = exports.BiometryType.none;
        }
        async checkBiometry() {
            return Promise.resolve({
                isAvailable: this.biometryType !== exports.BiometryType.none,
                biometryType: this.biometryType,
                reason: '',
                code: exports.BiometryErrorType.none,
            });
        }
        async authenticate(options) {
            return this.checkBiometry().then(({ isAvailable, biometryType }) => {
                if (isAvailable) {
                    if (
                    // eslint-disable-next-line no-alert
                    confirm((options === null || options === void 0 ? void 0 : options.reason) ||
                        `Authenticate with ${getBiometryName(biometryType)}?`)) {
                        return;
                    }
                    throw new BiometryError('User cancelled', exports.BiometryErrorType.userCancel);
                }
                throw new BiometryError('Biometry not available', exports.BiometryErrorType.biometryNotAvailable);
            });
        }
        async setBiometryType(type) {
            if (typeof type === 'undefined') {
                return Promise.resolve();
            }
            if (typeof type === 'string') {
                // eslint-disable-next-line no-prototype-builtins
                if (exports.BiometryType.hasOwnProperty(type)) {
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                    this.biometryType = exports.BiometryType[type];
                }
            }
            else {
                this.biometryType = type;
            }
            return Promise.resolve();
        }
    }

    var web = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BiometricAuthWeb: BiometricAuthWeb
    });

    // eslint-disable-next-line import/prefer-default-export
    class BiometricAuthNative extends BiometricAuthBase {
        constructor(capProxy) {
            super();
            this.checkBiometry = capProxy.checkBiometry;
            this.authenticate = capProxy.authenticate;
        }
        async checkBiometry() {
            // Never used, satisfy the compiler
            return Promise.resolve({
                isAvailable: true,
                biometryType: exports.BiometryType.none,
                reason: '',
                code: exports.BiometryErrorType.none,
            });
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
        async authenticate(options) { }
        // eslint-disable-next-line @typescript-eslint/require-await
        async setBiometryType(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        type) {
            throw this.unimplemented('setBiometryType is web only');
        }
    }

    var native = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BiometricAuthNative: BiometricAuthNative
    });

    exports.BiometricAuth = proxy;
    exports.BiometryError = BiometryError;
    exports.getBiometryName = getBiometryName;

    return exports;

})({}, capacitorExports, app);
