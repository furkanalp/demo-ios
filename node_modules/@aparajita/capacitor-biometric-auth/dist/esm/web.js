import { BiometricAuthBase } from './base';
import { BiometryError, BiometryErrorType, BiometryType } from './definitions';
import { getBiometryName } from './web-utils';
// eslint-disable-next-line import/prefer-default-export
export class BiometricAuthWeb extends BiometricAuthBase {
    constructor() {
        super(...arguments);
        this.biometryType = BiometryType.none;
    }
    async checkBiometry() {
        return Promise.resolve({
            isAvailable: this.biometryType !== BiometryType.none,
            biometryType: this.biometryType,
            reason: '',
            code: BiometryErrorType.none,
        });
    }
    async authenticate(options) {
        return this.checkBiometry().then(({ isAvailable, biometryType }) => {
            if (isAvailable) {
                if (
                // eslint-disable-next-line no-alert
                confirm((options === null || options === void 0 ? void 0 : options.reason) ||
                    `Authenticate with ${getBiometryName(biometryType)}?`)) {
                    return;
                }
                throw new BiometryError('User cancelled', BiometryErrorType.userCancel);
            }
            throw new BiometryError('Biometry not available', BiometryErrorType.biometryNotAvailable);
        });
    }
    async setBiometryType(type) {
        if (typeof type === 'undefined') {
            return Promise.resolve();
        }
        if (typeof type === 'string') {
            // eslint-disable-next-line no-prototype-builtins
            if (BiometryType.hasOwnProperty(type)) {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                this.biometryType = BiometryType[type];
            }
        }
        else {
            this.biometryType = type;
        }
        return Promise.resolve();
    }
}
